[{"title":"SpringBoot整合knife4j接口文档","url":"/posts/undefined.html","content":"官方地址：https://doc.xiaominfo.com/docs/quick-start\n本次示例使用Spring Boot 作为脚手架来快速集成Knife4j，Spring Boot版本2.7.2， Knife4j版本3.0.3\n完整代码参考我的springboot-init初始化脚手架 https://github.com/Liumingyao666/springboot-init\n如何整合？第一步：引入依赖在maven项目的pom.xml中引入Knife4j的依赖包，代码如下：\n&lt;dependency&gt;    &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;    &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;3.0.3&lt;/version&gt;&lt;/dependency&gt;\n\n第二步：创建Swagger配置依赖代码如下：\npackage com.liumingyao.springbootinit.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Profile;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;/** * Knife4j 接口文档配置 * https://doc.xiaominfo.com/knife4j/documentation/get_start.html * * @author &lt;a href=&quot;https://github.com/Liumingyao666&quot;&gt;刘铭垚&lt;/a&gt; *    */@Configuration@EnableSwagger2@Profile(&#123;&quot;dev&quot;, &quot;test&quot;&#125;)public class Knife4jConfig &#123;    @Bean    public Docket defaultApi2() &#123;        return new Docket(DocumentationType.SWAGGER_2)                .apiInfo(new ApiInfoBuilder()                        .title(&quot;接口文档&quot;)                        .description(&quot;springboot-init&quot;)                        .version(&quot;1.0&quot;)                        .build())                .select()                // 指定 Controller 扫描包路径                .apis(RequestHandlerSelectors.basePackage(&quot;com.liumingyao.springbootinit.controller&quot;))                .paths(PathSelectors.any())                .build();    &#125;&#125;\n\n第三步：application.yml配置在application.yml中提如下配置：\nspring:  mvc:    pathmatch:      matching-strategy: ant_path_matcher\n\n\n\n此时，启动Spring Boot工程，在浏览器中访问：http://localhost:你的端口/doc.html，即可打开接口文档，不需要写前端就能在线调试接口了~\n","tags":["Java","SpringBoot"]},{"title":"SpringBoot 项目初始模板","url":"/posts/undefined.html","content":"SpringBoot 项目初始模板基于 Java SpringBoot 的项目初始模板，整合了常用框架和主流业务的示例代码。\n项目地址：https://github.com/Liumingyao666/springboot-init\n模板特点主流框架 &amp; 特性\nSpring Boot 2.7.x（贼新）\nSpring MVC\nMyBatis + MyBatis Plus 数据访问（开启分页）\nSpring Boot 调试工具和项目处理器\nSpring AOP 切面编程\nSpring Scheduler 定时任务\nSpring 事务注解\n\n数据存储\nMySQL 数据库\nRedis 内存数据库\nElasticsearch 搜索引擎\n腾讯云 COS 对象存储\n\n工具类\nEasy Excel 表格处理\nHutool 工具库\nGson 解析库\nApache Commons Lang3 工具类\nLombok 注解\n\n业务特性\nSpring Session Redis 分布式登录\n全局请求响应拦截器（记录日志）\n全局异常处理器\n自定义错误码\n封装通用响应类\nSwagger + Knife4j 接口文档\n自定义权限注解 + 全局校验\n全局跨域处理\n长整数丢失精度解决\n多环境配置\n\n业务功能\n提供示例 SQL（用户、帖子、帖子点赞、帖子收藏表）\n用户登录、注册、注销、更新、检索、权限管理\n帖子创建、删除、编辑、更新、数据库检索、ES 灵活检索\n帖子点赞、取消点赞\n帖子收藏、取消收藏、检索已收藏帖子\n帖子全量同步 ES、增量同步 ES 定时任务\n支持微信开放平台登录\n支持微信公众号订阅、收发消息、设置菜单\n支持分业务的文件上传\n\n单元测试\nJUnit5 单元测试\n示例单元测试类\n\n架构设计\n合理分层\n\n快速上手\n所有需要修改的地方鱼皮都标记了 todo，便于大家找到修改的位置~\n\nMySQL 数据库1）修改 application.yml 的数据库配置为你自己的：\nspring:  datasource:    driver-class-name: com.mysql.cj.jdbc.Driver    url: jdbc:mysql://localhost:3306/my_db    username: root    password: 123456\n\n2）执行 sql/create_table.sql 中的数据库语句，自动创建库表\n3）启动项目，访问 http://localhost:8101/api/doc.html 即可打开接口文档，不需要写前端就能在线调试接口了~\n\nRedis 分布式登录1）修改 application.yml 的 Redis 配置为你自己的：\nspring:  redis:    database: 1    host: localhost    port: 6379    timeout: 5000    password: 123456\n\n2）修改 application.yml 中的 session 存储方式：\nspring:  session:    store-type: redis\n\n3）移除 MainApplication 类开头 @SpringBootApplication 注解内的 exclude 参数：\n修改前：\n@SpringBootApplication(exclude = &#123;RedisAutoConfiguration.class&#125;)\n\n修改后：\n@SpringBootApplication\n\nElasticsearch 搜索引擎1）修改 application.yml 的 Elasticsearch 配置为你自己的：\nspring:  elasticsearch:    uris: http://localhost:9200    username: root    password: 123456\n\n2）复制 sql/post_es_mapping.json 文件中的内容，通过调用 Elasticsearch 的接口或者 Kibana Dev Tools 来创建索引（相当于数据库建表）\nPUT post_v1&#123; 参数见 sql/post_es_mapping.json 文件&#125;\n\n这步不会操作的话需要补充下 Elasticsearch 的知识，或者自行百度一下~\n3）开启同步任务，将数据库的帖子同步到 Elasticsearch\n找到 job 目录下的 FullSyncPostToEs 和 IncSyncPostToEs 文件，取消掉 @Component 注解的注释，再次执行程序即可触发同步：\n// todo 取消注释开启任务//@Component","tags":["Java","SpringBoot"]},{"title":"用户中心项目文档","url":"/posts/undefined.html","content":"用户中心-项目文档目标：完整了解做项目的思路。\n项目源码用户中心后端项目源码：https://github.com/Liumingyao666/user-center-backend\n企业做项目流程需求分析 &#x3D;&gt; 设计（概要设计、详细设计）&#x3D;&gt; 技术选型 &#x3D;&gt; 初始化 &#x2F; 引入需要的技术 &#x3D;&gt; 写 Demo &#x3D;&gt; 写代码（实现业务逻辑） &#x3D;&gt; 测试（单元测试、系统测试）&#x3D;&gt; 代码提交 &#x2F; 代码评审 &#x3D;&gt; 部署 &#x3D;&gt; 发布上线\n技术选型前端：三件套 + React + 组件库 Ant Design + Umi + Ant Design Pro（现成的管理系统）\n后端：\n\njava\nspring（依赖注入框架，帮助你管理 Java 对象，集成一些其他的内容）\nspringmvc（web 框架，提供接口访问、restful接口等能力）\nmybatis（Java 操作数据库的框架，持久层框架，对 jdbc 的封装）\nmybatis-plus（对 mybatis 的增强，不用写 sql 也能实现增删改查）\nspringboot（快速启动 &#x2F; 快速集成项目。不用自己管理 spring 配置，不用自己整合各种框架）\njunit 单元测试库\nmysql 数据库\n\n部署：服务器 &#x2F; 容器（平台）\n3 种初始化 Java 项目的方式\nGitHub 搜现成的代码\nSpringBoot 官方的模板生成器（https://start.spring.io/）\n直接在 IDEA 开发工具中生成  ✔\n\n如果要引入 java 的包，可以去 maven 中心仓库寻找（http://mvnrepository.com/）\n数据库设计什么是数据库？存数据的\n数据库里有什么？数据表（理解为 excel 表格）\njava 操作数据库？程序代替人工\n什么是设计数据库表？有哪些表（模型）？表中有哪些字段？字段的类型？数据库字段添加索引？表与表之间的关联？\n举例：性别是否需要加索引？\n用户表设计id（主键）bigint\nusername 昵称  varchar\nuserAccount 登录账号 \navatarUrl 头像 varchar\ngender 性别 tinyint\nuserPassword 密码  varchar\nphone 电话 varchar\nemail 邮箱 varchar\nuserStatus 用户状态 int  0 - 正常 \ncreateTime 创建时间（数据插入时间）datetime\nupdateTime 更新时间（数据更新时间）datetime\nisDelete 是否删除 0 1（逻辑删除）tinyint\nuserRole 用户角色 0 - 普通用户 1 - 管理员\n自动生成器的使用mybatis-plus配置\npackage com.liumingyao.testmianshi.config;import com.baomidou.mybatisplus.annotation.DbType;import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;import org.mybatis.spring.annotation.MapperScan;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * MyBatis Plus 配置 * * @author https://github.com/liliumingyao */@Configuration@MapperScan(&quot;com.liumingyao.testmianshi.mapper&quot;)public class MyBatisPlusConfig &#123;    /**     * 拦截器配置     *     * @return     */    @Bean    public MybatisPlusInterceptor mybatisPlusInterceptor() &#123;        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();        // 分页插件        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));        return interceptor;    &#125;&#125;\n\n\n\nMyBatisX 插件，自动根据数据库生成：\n\ndomain：实体对象\nmapper：操作数据库的对象\nmapper.xml：定义了 mapper 对象和数据库的关联，可以在里面自己写 SQL\nservice：包含常用的增删改查\nserviceImpl：具体实现 service\n\n从而提高开发效率！\n注册逻辑设计\n用户在前端输入账户和密码、以及校验码（todo）\n校验用户的账户、密码、校验密码，是否符合要求\n非空\n账户长度 不小于 4 位\n密码就 不小于 8 位吧\n账户不能重复\n账户不包含特殊字符\n密码和校验密码相同\n\n\n对密码进行加密（密码千万不要直接以明文存储到数据库中）\n向数据库插入用户数据\n\n登录功能接口设计接受参数：用户账户、密码\n请求类型：POST \n请求体：JSON 格式的数据\n\n请求参数很长时不建议用 get\n\n返回值：用户信息（ 脱敏 ）\n登录逻辑\n校验用户账户和密码是否合法\n\n非空\n账户长度不小于 4 位\n密码就不小于 8 位\n账户不包含特殊字符\n\n\n校验密码是否输入正确，要和数据库中的密文密码去对比\n\n用户信息脱敏，隐藏敏感信息，防止数据库中的字段泄露\n\n我们要记录用户的登录态（session），将其存到服务器上（用后端 SpringBoot 框架封装的服务器 tomcat 去记录）\ncookie\n\n返回脱敏后的用户信息\n\n\npackage com.liumingyao.testmianshi.service.impl;import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import com.liumingyao.testmianshi.common.ErrorCode;import com.liumingyao.testmianshi.exception.BusinessException;import com.liumingyao.testmianshi.mapper.UserMapper;import com.liumingyao.testmianshi.model.User;import com.liumingyao.testmianshi.model.dto.UserLoginDTO;import com.liumingyao.testmianshi.model.dto.UserRegisterDTO;import com.liumingyao.testmianshi.model.vo.UserVO;import com.liumingyao.testmianshi.service.UserService;import org.apache.commons.lang3.StringUtils;import org.springframework.beans.BeanUtils;import org.springframework.stereotype.Service;import org.springframework.util.DigestUtils;import javax.servlet.http.HttpServletRequest;/*** @author LiuMingyao* @description 针对表【user(用户)】的数据库操作Service实现* @createDate 2023-10-25 09:34:39*/@Servicepublic class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt;    implements UserService&#123;    /**     * 盐值，混淆密码     */    private static final String SALT = &quot;liumingyao&quot;;    @Override    public long register(UserRegisterDTO userRegisterDTO) &#123;        if (userRegisterDTO == null)&#123;            throw new BusinessException(ErrorCode.PARAMS_ERROR);        &#125;        String userAccount = userRegisterDTO.getUserAccount();        String userPassword = userRegisterDTO.getUserPassword();        String userConfirmPassword = userRegisterDTO.getUserConfirmPassword();        if (StringUtils.isAnyBlank(userAccount, userPassword, userConfirmPassword))&#123;            throw new BusinessException(ErrorCode.PARAMS_ERROR);        &#125;        if (!userConfirmPassword.equals(userPassword))&#123;            throw new BusinessException(ErrorCode.PARAMS_ERROR, &quot;两次输入的密码不一致&quot;);        &#125;        synchronized (userAccount.intern()) &#123;            // 账户不能重复            Long count = this.query().eq(&quot;user_account&quot;, userAccount).count();            if (count &gt; 0)&#123;                throw new BusinessException(ErrorCode.NOT_FOUND_ERROR, &quot;重复注册&quot;);            &#125;            // 2. 加密            String encryptPassword = DigestUtils.md5DigestAsHex((SALT + userPassword).getBytes());            // 3. 插入数据            User user = new User();            user.setUserAccount(userAccount);            user.setUserPassword(encryptPassword);            boolean saveResult = this.save(user);            if (!saveResult) &#123;                throw new BusinessException(ErrorCode.SYSTEM_ERROR, &quot;注册失败，数据库错误&quot;);            &#125;            return user.getId();        &#125;    &#125;    @Override    public UserVO login(UserLoginDTO userLoginDTO, HttpServletRequest request) &#123;        if (userLoginDTO == null)&#123;            throw new BusinessException(ErrorCode.PARAMS_ERROR);        &#125;        String userAccount = userLoginDTO.getUserAccount();        String userPassword = userLoginDTO.getUserPassword();        if (StringUtils.isAnyBlank(userAccount, userPassword))&#123;            throw new BusinessException(ErrorCode.PARAMS_ERROR);        &#125;        String encryptPassword = DigestUtils.md5DigestAsHex((SALT + userPassword).getBytes());        QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();        queryWrapper.eq(&quot;user_account&quot;, userAccount).eq(&quot;user_password&quot;, encryptPassword);        User user = this.getOne(queryWrapper);        if (user == null)&#123;            throw new BusinessException(ErrorCode.NOT_FOUND_ERROR, &quot;登录失败&quot;);        &#125;        UserVO userVO = new UserVO();        BeanUtils.copyProperties(user, userVO);        request.getSession().setAttribute(&quot;user_login&quot;, userVO);        return userVO;    &#125;&#125;\n\n\n\n获取当前用户@GetMapping(&quot;/current&quot;)    public BaseResponse&lt;UserVO&gt; getLoginUser(HttpServletRequest request)&#123;        UserVO userVO = (UserVO) request.getSession().getAttribute(&quot;user_login&quot;);        if (userVO == null || userVO.getId() &lt; 0)&#123;            throw new BusinessException(ErrorCode.NOT_LOGIN_ERROR);        &#125;        Long userId = userVO.getId();        User user = userService.getById(userId);        if (user == null)&#123;            throw new BusinessException(ErrorCode.NOT_LOGIN_ERROR);        &#125;        BeanUtils.copyProperties(user, userVO);        return ResultUtils.success(userVO);    &#125;\n\n\n\n\n\n实现控制层 Controller 封装请求\napplication.yml 指定接口全局路径前缀：\nservlet:  context-path: /api\n\n控制器注解：\n@RestController 适用于编写 restful 风格的 api，返回值默认为 json 类型\n\n校验写在哪里？\n\ncontroller 层倾向于对请求参数本身的校验，不涉及业务逻辑本身（越少越好）\nservice 层是对业务逻辑的校验（有可能被 controller 之外的类调用）\n\n如何知道是哪个用户登录了？\njavaweb 这一块的知识\n\n\n连接服务器端后，得到一个 session 状态（匿名会话），返回给前端\n\n登录成功后，得到了登录成功的 session，并且给该session设置一些值（比如用户信息），返回给前端一个设置 cookie 的 ”命令“ \nsession &#x3D;&gt; cookie \n\n前端接收到后端的命令后，设置 cookie，保存到浏览器内\n\n前端再次请求后端的时候（相同的域名），在请求头中带上cookie去请求\n\n后端拿到前端传来的 cookie，找到对应的 session\n\n后端从 session 中可以取出基于该 session 存储的变量（用户的登录信息、登录名）\n\n\n用户管理接口设计关键：必须鉴权！！！\n\n查询用户（允许根据用户名查询）\n删除用户\n\n写代码流程\n先做设计\n代码实现\n持续优化！！！（复用代码、提取公共逻辑 &#x2F; 常量）\n\n前后端交互前端需要向后端发送请求才能获取数据 &#x2F; 执行操作。\n怎么发请求：前端使用 ajax 来请求后端\n前端请求库及封装关系\naxios 封装了 ajax\n\nrequest 是 ant design 项目又封装了一次\n\n\n追踪 request 源码：用到了 umi 的插件、requestConfig 配置文件\n代理正向代理：替客户端向服务器发送请求，可以解决跨域问题\n反向代理：替服务器统一接收请求。\n怎么实现代理？\n\nNginx 服务器\nNode.js 服务器\n\n举例原本请求：http://localhost:8000/api/user/login\n代理到请求：http://localhost:8080/api/user/login\n\n前端框架介绍Ant Design Pro（Umi 框架）权限管理\napp.tsx：项目全局入口文件，定义了整个项目中使用的公共数据（比如用户信息）\naccess.ts 控制用户的访问权限\n\n获取初始状态流程：首次访问页面（刷新页面），进入 app.tsx，执行 getInitialState 方法，该方法的返回值就是全局可用的状态值。\nProComponents 高级表单\n通过 columns 定义表格有哪些列\ncolumns 属性\ndataIndex 对应返回数据对象的属性\ntitle 表格列名\ncopyable 是否允许复制\nellipsis 是否允许缩略\nvalueType：用于声明这一列的类型（dateTime、select）\n\n\n\n框架关系Ant Design 组件库 &#x3D;&gt; 基于 React 实现\nAnt Design Procomponents &#x3D;&gt; 基于 Ant Design 实现\nAnt Design Pro 后台管理系统 &#x3D;&gt; 基于 Ant Design + React + Ant Design Procomponents + 其他的库实现\n其他知识MFSU：前端编译优化\n后端优化通用返回对象目的：给对象补充一些信息，告诉前端这个请求在业务层面上是成功还是失败\n200、404、500、502、503\n&#123;    &quot;name&quot;: &quot;yupi&quot;&#125;↓// 成功&#123;    &quot;code&quot;: 0 // 业务状态码    &quot;data&quot;: &#123;        &quot;name&quot;: &quot;yupi&quot;    &#125;,\t&quot;message&quot;: &quot;ok&quot;&#125;// 错误&#123;    &quot;code&quot;: 50001 // 业务状态码    &quot;data&quot;: null\t&quot;message&quot;: &quot;用户操作异常、xxx&quot;&#125;\n\n自定义错误码，返回类支持返回正常和错误\n实现package com.liumingyao.testmianshi.common;public enum ErrorCode &#123;    SUCCESS(0, &quot;ok&quot;),    PARAMS_ERROR(40000, &quot;请求参数错误&quot;),    NOT_LOGIN_ERROR(40100, &quot;未登录&quot;),    NO_AUTH_ERROR(40101, &quot;无权限&quot;),    NOT_FOUND_ERROR(40400, &quot;请求数据不存在&quot;),    FORBIDDEN_ERROR(40300, &quot;禁止访问&quot;),    SYSTEM_ERROR(50000, &quot;系统内部异常&quot;),    OPERATION_ERROR(50001, &quot;操作失败&quot;)    ;    private final int code;    private final String message;    ErrorCode(int code, String message) &#123;        this.code = code;        this.message = message;    &#125;    public int getCode() &#123;        return code;    &#125;    public String getMessage() &#123;        return message;    &#125;&#125;\n\npackage com.liumingyao.testmianshi.common;import lombok.Data;import java.io.Serializable;@Datapublic class BaseResponse&lt;T&gt; implements Serializable &#123;    private int code;    private T data;    private String message;    public BaseResponse(int code, T data, String message) &#123;        this.code = code;        this.data = data;        this.message = message;    &#125;    public BaseResponse(ErrorCode errorCode)&#123;        this(errorCode.getCode(), null, errorCode.getMessage());    &#125;&#125;\n\npackage com.liumingyao.testmianshi.common;public class ResultUtils &#123;    /**     * 成功     *     * @param data     * @param &lt;T&gt;     * @return     */    public static &lt;T&gt; BaseResponse&lt;T&gt; success(T data) &#123;        return new BaseResponse&lt;&gt;(0, data, &quot;ok&quot;);    &#125;    /**     * 失败     *     * @param errorCode     * @return     */    public static BaseResponse error(ErrorCode errorCode) &#123;        return new BaseResponse&lt;&gt;(errorCode);    &#125;    /**     * 失败     *     * @param code     * @param message     * @return     */    public static BaseResponse error(int code, String message) &#123;        return new BaseResponse(code, null, message);    &#125;    /**     * 失败     *     * @param errorCode     * @return     */    public static BaseResponse error(ErrorCode errorCode, String message) &#123;        return new BaseResponse(errorCode.getCode(), null, message);    &#125;&#125;\n\n\n\n封装全局异常处理器实现\n定义业务异常类\n\n相对于 java 的异常类，支持更多字段\n自定义构造函数，更灵活 &#x2F; 快捷的设置字段\n\n\n编写全局异常处理器（利用 Spring AOP，在调用方法前后进行额外的处理）\n\n\npackage com.liumingyao.testmianshi.exception;import com.liumingyao.testmianshi.common.ErrorCode;public class BusinessException extends RuntimeException&#123;    private final int code;    public BusinessException(String message, int code) &#123;        super(message);        this.code = code;    &#125;    public BusinessException(ErrorCode errorCode) &#123;        super(errorCode.getMessage());        this.code = errorCode.getCode();    &#125;    public BusinessException(ErrorCode errorCode, String message) &#123;        super(message);        this.code = errorCode.getCode();    &#125;    public int getCode() &#123;        return code;    &#125;&#125;\n\n\n\npackage com.liumingyao.testmianshi.exception;import com.liumingyao.testmianshi.common.BaseResponse;import com.liumingyao.testmianshi.common.ErrorCode;import com.liumingyao.testmianshi.common.ResultUtils;import lombok.extern.slf4j.Slf4j;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.RestControllerAdvice;@RestControllerAdvice@Slf4jpublic class GlobalExceptionHandler &#123;    @ExceptionHandler(BusinessException.class)    public BaseResponse&lt;?&gt; businessExceptionHandler(BusinessException e)&#123;        log.error(&quot;BusinessException&quot;,e);        return ResultUtils.error(e.getCode(), e.getMessage());    &#125;    @ExceptionHandler(RuntimeException.class)    public BaseResponse&lt;?&gt; runtimeExceptionHandler(RuntimeException e) &#123;        log.error(&quot;RuntimeException&quot;, e);        return ResultUtils.error(ErrorCode.SYSTEM_ERROR, &quot;系统错误&quot;);    &#125;&#125;\n\n\n\n\n作用\n捕获代码中所有的异常，内部消化，让前端得到更详细的业务报错 &#x2F; 信息\n同时屏蔽掉项目框架本身的异常（不暴露服务器内部状态）\n集中处理，比如记录日志\n\n前端优化全局响应处理应用场景：我们需要对接口的 通用响应 进行统一处理，比如从 response 中取出 data；或者根据 code 去集中处理错误，比如用户未登录、没权限之类的。\n优势：不用在每个接口请求中都去写相同的逻辑\n实现：参考你用的请求封装工具的官方文档，比如 umi-request（https://github.com/umijs/umi-request#interceptor、https://blog.csdn.net/huantai3334/article/details/116780020）。如果你用 axios，参考 axios 的文档。\n创建新的文件，在该文件中配置一个全局请求类。在发送请求时，使用我们自己的定义的全局请求类。\n用户校验\n仅适用于用户可信的情况\n\n先让用户自己填：2 - 5 位编号，全凭自觉。\n后台补充对编号的校验：长度校验、唯一性校验\n前端补充输入框，适配后端。\n\n后期拉取星球数据，定期清理违规用户\n\n多环境参考文章：https://blog.csdn.net/weixin_41701290/article/details/120173283\n本地开发：localhost（127.0.0.1）\n多环境：指同一套项目代码在不同的阶段需要根据实际情况来调整配置并且部署到不同的机器上。\n为什么需要？\n\n每个环境互不影响\n区分不同的阶段：开发 &#x2F; 测试 &#x2F; 生产\n对项目进行优化：\n本地日志级别\n精简依赖，节省项目体积\n项目的环境 &#x2F; 参数可以调整，比如 JVM 参数\n\n\n\n针对不同环境做不同的事情。\n多环境分类：\n\n本地环境（自己的电脑）localhost\n开发环境（远程开发）大家连同一台机器，为了大家开发方便\n测试环境（测试）开发 &#x2F; 测试 &#x2F; 产品，单元测试 &#x2F; 性能测试 &#x2F; 功能测试 &#x2F; 系统集成测试，独立的数据库、独立的服务器\n预发布环境（体验服）：和正式环境一致，正式数据库，更严谨，查出更多问题\n正式环境（线上，公开对外访问的项目）：尽量不要改动，保证上线前的代码是 “完美” 运行\n沙箱环境（实验环境）：为了做实验\n\n前端多环境实战\n请求地址\n\n开发环境：localhost:8000\n\n线上环境：user-backend.code-nav.cn\n\n\nstartFront(env) &#123;    if(env === &#x27;prod&#x27;) &#123;        // 不输出注释         // 项目优化        // 修改请求地址    &#125; else &#123;        // 保持本地开发逻辑    &#125;&#125;\n\n用了 umi 框架，build 时会自动传入 NODE_ENV &#x3D;&#x3D; production 参数，start NODE_ENV 参数为 development\n\n启动方式\n\n开发环境：npm run start（本地启动，监听端口、自动更新）\n线上环境：npm run build（项目构建打包），可以使用 serve 工具启动（npm i -g serve）\n\n\n项目的配置\n不同的项目（框架）都有不同的配置文件，umi 的配置文件是 config，可以在配置文件后添加对应的环境名称后缀来区分开发环境和生产环境。参考文档：https://umijs.org/zh-CN/docs/deployment\n\n开发环境：config.dev.ts\n生产环境：config.prod.ts\n公共配置：config.ts 不带后缀\n\n\n\n后端多环境实战SpringBoot 项目，通过 application.yml 添加不同的后缀来区分配置文件\n可以在启动项目时传入环境变量：\njava -jar .\\user-center-backend-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod\n\n主要是改：\n\n依赖的环境地址\n\n数据库地址\n\n缓存地址\n\n消息队列地址\n\n项目端口号\n\n\n\n服务器配置\n\n\n项目部署参考文章：https://www.bilibili.com/read/cv16179200\n需要 Linux 服务器（建议大家用 CentOS 8+ &#x2F; 7.6 以上）\n原始部署什么都自己装\n前端需要 web 服务器：nginx 、apache、tomcat\n安装 nginx 服务器：\n\n用系统自带的软件包管理器快速安装，比如 centos 的 yum\n\n自己到官网安装（参考文章）\ncurl -o nginx-1.21.6.tar.gz http://nginx.org/download/nginx-1.21.6.tar.gztar -zxvf nginx-1.21.6.tar.gzcd nginx-1.21.6   37  2022-04-17 23:30:09 yum install pcre pcre-devel -y   39  2022-04-17 23:30:59 yum install openssl openssl-devel -y   41  2022-04-17 23:31:57 ./configure --with-http_ssl_module --with-http_v2_module --with-stream   42  2022-04-17 23:32:13 make   43  2022-04-17 23:32:54 make install   48  2022-04-17 23:33:40 ls /usr/local/nginx/sbin/nginx   vim /etc/profile  在最后一行添加：export PATH=$PATH:/usr/local/nginx/sbin\t    nginx    netstat -ntlp 查看启动情况\n\n注意 nginx 权限\n\n\n后端java、maven\n安装：\nyum install -y java-1.8.0-openjdk*curl -o apache-maven-3.8.5-bin.tar.gz https://dlcdn.apache.org/maven/maven-3/3.8.5/binaries/apache-maven-3.8.5-bin.tar.gzgit clone xxx 下载代码打包构建，跳过测试mvn package -DskipTestsjava -jar ./user-center-backend-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod\n\n\n\n宝塔 Linux 部署Linux 运维面板\n官方安装教程：https://www.bt.cn/new/download.html\n方便管理服务器、方便安装软件\n前端托管前端腾讯云 web 应用托管（比容器化更傻瓜式，不需要自己写构建应用的命令，就能启动前端项目）\n\nhttps://console.cloud.tencent.com/webify/new\n\n\n小缺点：需要将代码放到代码托管平台上\n优势：不用写命令、代码更新时自动构建\n\nDocker 部署docker 是容器，可以将项目的环境（比如 java、nginx）和项目的代码一起打包成镜像，所有同学都能下载镜像，更容易分发和移植。\n再启动项目时，不需要敲一大堆命令，而是直接下载镜像、启动镜像就可以了。\ndocker 可以理解为软件安装包。\nDocker 安装：https://www.docker.com/get-started/ 或者宝塔安装\nDockerfile 用于指定构建 Docker 镜像的方法\nDockerfile 一般情况下不需要完全从 0 自己写，建议去 github、gitee 等托管平台参考同类项目（比如 springboot）\nDockerfile 编写：\n\nFROM 依赖的基础镜像\nWORKDIR 工作目录\nCOPY 从本机复制文件\nRUN 执行命令\nCMD &#x2F; ENTRYPOINT（附加额外参数）指定运行容器时默认执行的命令\n\n根据 Dockerfile 构建镜像：\n# 后端docker build -t user-center-backend:v0.0.1 .# 前端docker build -t user-center-front:v0.0.1 .\n\nDocker 构建优化：减少尺寸、减少构建时间（比如多阶段构建，可以丢弃之前阶段不需要的内容）\ndocker run 启动：\n# 前端docker run -p 80:80 -d user-center-frontend:v0.0.1# 后端docker run -p 8080:8080 user-center-backend:v0.0.1\n\n虚拟化\n\n端口映射：把本机的资源（实际访问地址）和容器内部的资源（应用启动端口）进行关联\n目录映射：把本机的端口和容器应用的端口进行关联\n\n进入容器：\ndocker exec -i -t  fee2bbb7c9ee /bin/bash\n\n\n\n查看进程：\ndocker ps \n\n\n\n查看日志：\ndocker logs -f [container-id]\n\n\n\n杀死容器：\ndocker kill\n\n\n\n强制删除镜像：\ndocker rmi -f\n\n\n\nDocker 平台部署\n云服务商的容器平台（腾讯云、阿里云）\n面向某个领域的容器平台（前端 &#x2F; 后端微信云托管）要花钱！\n\n容器平台的好处：\n\n不用输命令来操作，更方便省事\n不用在控制台操作，更傻瓜式、更简单\n大厂运维，比自己运维更省心\n额外的能力，比如监控、告警、其他（存储、负载均衡、自动扩缩容、流水线）\n\n爽就完事了！！！\n绑定域名前端项目访问流程：用户输入网址 &#x3D;&gt; 域名解析服务器（把网址解析为 ip 地址 &#x2F; 交给其他的域名解析服务） &#x3D;&gt; 服务器 &#x3D;&gt;（防火墙）&#x3D;&gt; nginx 接收请求，找到对应的文件，返回文件给前端 &#x3D;&gt; 前端加载文件到浏览器中（js、css） &#x3D;&gt; 渲染页面\n后端项目访问流程：用户输入网址 &#x3D;&gt; 域名解析服务器 &#x3D;&gt; 服务器 &#x3D;&gt; nginx 接收请求 &#x3D;&gt; 后端项目（比如 8080端口）\nnginx 反向代理的作用：替服务器接收请求，转发请求\n跨域问题解决浏览器为了用户的安全，仅允许向 同域名、同端口 的服务器发送请求。\n如何解决跨域？\n最直接的方式：把域名、端口改成相同的\n添加跨域头让服务器告诉浏览器：允许跨域（返回 cross-origin-allow 响应头）\n1. 网关支持（Nginx）# 跨域配置location ^~ /api/ &#123;    proxy_pass http://127.0.0.1:8080/api/;    add_header &#x27;Access-Control-Allow-Origin&#x27; $http_origin;    add_header &#x27;Access-Control-Allow-Credentials&#x27; &#x27;true&#x27;;    add_header Access-Control-Allow-Methods &#x27;GET, POST, OPTIONS&#x27;;    add_header Access-Control-Allow-Headers &#x27;*&#x27;;    if ($request_method = &#x27;OPTIONS&#x27;) &#123;        add_header &#x27;Access-Control-Allow-Credentials&#x27; &#x27;true&#x27;;        add_header &#x27;Access-Control-Allow-Origin&#x27; $http_origin;        add_header &#x27;Access-Control-Allow-Methods&#x27; &#x27;GET, POST, OPTIONS&#x27;;        add_header &#x27;Access-Control-Allow-Headers&#x27; &#x27;DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range&#x27;;        add_header &#x27;Access-Control-Max-Age&#x27; 1728000;        add_header &#x27;Content-Type&#x27; &#x27;text/plain; charset=utf-8&#x27;;        add_header &#x27;Content-Length&#x27; 0;        return 204;    &#125;&#125;\n\n2. 修改后端服务\n配置 @CrossOrigin 注解\n\n添加 web 全局请求拦截器\n@Configurationpublic class WebMvcConfg implements WebMvcConfigurer &#123;     @Override    public void addCorsMappings(CorsRegistry registry) &#123;        //设置允许跨域的路径        registry.addMapping(&quot;/**&quot;)                //设置允许跨域请求的域名                //当**Credentials为true时，**Origin不能为星号，需为具体的ip地址【如果接口不带cookie,ip无需设成具体ip】                .allowedOrigins(&quot;http://localhost:9527&quot;, &quot;http://127.0.0.1:9527&quot;, &quot;http://127.0.0.1:8082&quot;, &quot;http://127.0.0.1:8083&quot;)                //是否允许证书 不再默认开启                .allowCredentials(true)                //设置允许的方法                .allowedMethods(&quot;*&quot;)                //跨域允许时间                .maxAge(3600);    &#125;&#125;\n\n定义新的 corsFilter Bean，参考：https://www.jianshu.com/p/b02099a435bd\n\n\n项目优化点\n功能扩充\n管理员创建用户、修改用户信息、删除用户\n上传头像\n按照更多的条件去查询用户\n更改权限\n\n\n修改 Bug\n项目登录改为分布式 session（单点登录 - redis）\n通用性\nset-cookie domain 域名更通用，比如改为 *.xxx.com\n把用户管理系统 &#x3D;&gt; 用户中心（之后所有的服务都请求这个后端）\n\n\n后台添加全局请求拦截器（统一去判断用户权限、统一记录请求日志）\n\n"}]